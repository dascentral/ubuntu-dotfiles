#!/usr/bin/perl

use Getopt::Std;

#
# Backup a sql database to flat file.
#

#
# Usage: sqlbackup.pl database user password <options>
#   user:      the username to log into the database with
#   password:  the password to use for same
#   database:  the database to backup
#   -f:        the filename to write the dump to, if not the standard one
#   -d:        the directory to write the file to, if not the database name directory
#   -i:        perform the isamchk on the database
#   -h:        hostname to connect to
#   -z:        gzip option 
#

sub usage {
    print "
Usage: $0 <database> <user> <password> [-f <file>] [-d <dir>] [-i] [-h <host>] -z
 database:  the database to backup
 user:      the username to log into the database with
 password:  the password to use for same
 -f <file>: the filename to write the dump to, if not the standard one 
 -d <dir>:  the directory to write the file to, if not the database name directory
 -i:        perform an isamchk on the database (default does not)
 -h <host>: the hostname to connect to
 -z:        gzip option
";
    return;
}

# Setup defaults and parse command line options
my($database) = shift(@ARGV);  #no default
my($user) = shift(@ARGV);  #no default
my($password) = shift(@ARGV);  #no default

#Set up dirs for mysqldump & gzip (needed for compatability with VPS V2s
my($msdump_path) = '';
if (-e $ENV{HOME} . "/usr/bin/mysqldump"){
    $msdump_path = $ENV{HOME} . "/usr/bin/";
} else {
    $msdump_path = "/usr/bin/";
}

my($gz_path) = '';
if (-e $ENV{HOME} . "/bin/gzip"){  
    $gz_path = $ENV{HOME} . "/bin/";
} else {
    $gz_path = "/bin/";
}

my($lib_path) = '';
if (-e $ENV{HOME} . "/usr/lib/"){
    $lib_path = $ENV{HOME} . "/usr/lib/";
} else {
    $lib_path = "/usr/lib/";
}


# pull other arguments
&Getopt::Std::getopts('zif:d:h:', \%options);
my($file) = &default_file;  # default to today's date
my($dir) = '';              # default to database
my($isamchk) = 0;           # default to not do a check
my($gzipit) = 0;            # default to not zip file
my($host) = "localhost";    # default to localhost

#$ENV{'LD_LIBRARY_PATH'} = $ENV{'HOME'}."/usr/lib/";
$ENV{'LD_LIBRARY_PATH'} = $lib_path;
umask(077);

# did they supply the basic arguments?
if (!$user || !$password || !$database) {
    &usage;
    exit;
}

# did they supply a filename?
if ($options{'f'}) {
    $file = $options{'f'};
}

# did they supply a directory?
if ($options{'d'}) {
    $dir = $options{'d'};
} else {
    $dir = $database;
}

# does it exist?  If not try to create it.
-d $dir || mkdir($dir,0700); 

# Still doesn't exist?  Fail!
-d $dir || die "No such directory ($dir) exists and I cannot create it, exiting.";

# do they want an isamchk?
if ($options{'i'}) {
    $isamchk = 1;
}

# did they supply a hostname?
if ($options{'h'}) {
    $host = $options{'h'};
}

# did they want the file zippped with gzip?
if ($options{'z'}) {
    $gzipit = 1;
}

# here is where to put the dump
$filename = $dir . "/" . $file;

#does this file exist?  We cannot overwrite...
-f $filename && die "This filename ($filename) already exists, exiting.";

# Create the file, set the permissions
open(FILE, ">>$filename");
close(FILE);

-f $filename || die "No such filename ($dir) exists and I cannot create it, exiting.";

# ok, we're ready to go!

# first, do the dump!
&dumpsql($database, $user, $password, $host, $filename);

# if they wanted an isamchk, do that too!
if ($isamchk) {
    &isamchk($database);
}

# if they want it zipped it will be so.
if ($gzipit) {
    &gzip_file($filename);
}

exit;

#
# isamchk: run the isamchk program over your tables
#
# Arguments:
#   database: name of database to connect to
# Returns:
#   success: it returns
#   failure: it doesn't return at all
#
sub isamchk {
    my($d) = @_;
    my($rc);
    $rc = system("/usr/bin/isamchk -s -a /var/lib/mysql/$d/*.ISM");
    $rc && die "isamchk failed";
    return;
}

#
# dumpsql: dump a sql database to a flat file.  You might need this
#   someday to recover from a backup.
# Arguments:
#   database: name of database to connect to
#   user:     name of user to connect with
#   password: password to use when connecting
#   host:     host to connect to
#   filename: where to write the dump
# Returns:
#   success: it returns
#   failure: it doesn't return at all
#
sub dumpsql {
    my($d, $u, $p, $h, $f) = @_;
    my($rc);

    $rc = system("${msdump_path}mysqldump --host=\'$h\' --user=\'$u\' --password=\'$p\' $d > $f");
    $rc && die "mysql dump failed";
    -z $f && die "mysql dump failed, $f zero length";
    return;
}

#
# gzip_file: Zip filename
# Args: filename
# Returns: 
#   success: it returns
#   failure: it doesn't return at all
sub gzip_file {
    my($f) = @_;
    $rc = system("${gz_path}gzip $f");
    $rc && die "gzip failed";
    return;
}

#
# default_file: Create a default filename
# Args: none
# Returns: a string of today's date
#
sub default_file {
    my(@time) = localtime;
    return sprintf("%04d%02d%02d_%02d%02d%02d",($time[5]+1900),($time[4]+1),$time[3],$time[2],$time[1],$time[0]);
}
